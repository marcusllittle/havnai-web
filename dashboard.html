<!DOCTYPE html>
<html lang="en">
  <head>
    <script>
      // Expose API base for static deployments (mirrors Next.js env)
      window.NEXT_PUBLIC_API_BASE_URL = "/api";
    </script>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>HavnAI Grid Dashboard · Stage 6 → 7</title>
    <meta
      name="description"
      content="Development dashboard for the HavnAI decentralized GPU network: models, jobs, and nodes in real time."
    />
    <link rel="icon" type="image/png" href="/HavnAI-logo.png" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700&family=Exo+2:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="dashboard.css" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  </head>
  <body class="site-body">
    <div class="bg-aurora"></div>
    <header class="site-header">
      <div class="header-inner">
        <a href="/" class="brand">
          <img src="/HavnAI-logo.png" alt="HavnAI" class="brand-logo" />
          <div class="brand-text">
            <span class="brand-stage">Stage 6 → 7 Alpha</span>
            <span class="brand-name">HavnAI Grid</span>
          </div>
        </a>
        <button class="nav-toggle" id="navToggle" aria-label="Toggle navigation">
          <span></span><span></span>
        </button>
        <nav class="nav-links" id="primaryNav">
          <a href="/#home">Home</a>
          <a href="/#how">How It Works</a>
          <a href="/#smart-routing">Smart Routing</a>
          <a href="/#rewards">Rewards</a>
          <a href="/#models">Models</a>
          <a href="/library">My Library</a>
          <a href="/dashboard" class="nav-active">Dashboard</a>
          <a href="https://joinhavn.io/alpha" target="_blank">Join Alpha</a>
        </nav>
      </div>
    </header>

    <main class="dashboard-main">
      <!-- SUMMARY ROW -->
      <section class="section dashboard-summary">
        <div class="section-header">
          <h2>Grid Telemetry</h2>
          <p>Live stats from the coordinator, powered by <code>/api/models/stats</code> and <code>/nodes</code>.</p>
        </div>
        <div class="summary-grid">
          <article class="summary-card">
            <span class="label">Active Nodes</span>
            <strong id="metricActiveNodes">--</strong>
          </article>
          <article class="summary-card">
            <span class="label">Jobs (24h)</span>
            <strong id="metricJobs24h">--</strong>
          </article>
          <article class="summary-card">
            <span class="label">Success Rate</span>
            <strong id="metricSuccessRate">--%</strong>
          </article>
          <article class="summary-card">
            <span class="label">Top Model</span>
            <strong id="metricTopModel">--</strong>
          </article>
          <article class="summary-card">
            <span class="label">Total Nodes (all)</span>
            <strong id="metricTotalNodes">--</strong>
          </article>
          <article class="summary-card">
            <span class="label">Avg Utilization</span>
            <strong id="metricAvgUtil">--%</strong>
          </article>
        </div>
        <div class="summary-meta">
          <span id="summaryUpdated">Last Updated: --</span>
        </div>
      </section>

      <!-- MODEL LEADERBOARD -->
      <section class="section">
        <div class="section-header header-row">
          <div>
            <h2>Model Leaderboard</h2>
            <p>Weighted routing favors higher-tier models. Sorted by weight.</p>
          </div>
          <div class="model-controls">
            <label for="modelFilter">Filter</label>
            <select id="modelFilter">
              <option value="all">All</option>
              <option value="realism">Realism</option>
              <option value="anime">Anime</option>
              <option value="cartoon">Cartoon</option>
            </select>
          </div>
        </div>
        <div class="table-wrapper">
          <table class="leaderboard-table">
            <thead>
              <tr>
                <th>Rank</th>
                <th>Model</th>
                <th>Weight</th>
                <th>Tags</th>
              </tr>
            </thead>
            <tbody id="leaderboardBody">
              <tr>
                <td colspan="4">Loading model registry...</td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>

      <!-- JOBS LINE GRAPH -->
      <section class="section dashboard-chart">
        <div class="section-header header-row">
          <div>
            <h2>Jobs Over Time</h2>
            <p>Live job throughput from recent activity.</p>
          </div>
          <div class="range-toggle">
            <button type="button" data-range="1h" class="range-btn active">1h</button>
            <button type="button" data-range="6h" class="range-btn">6h</button>
            <button type="button" data-range="24h" class="range-btn">24h</button>
          </div>
        </div>
        <div class="chart-container">
          <canvas id="jobsChart" aria-label="Jobs over time" role="img"></canvas>
        </div>
      </section>

      <!-- JOB FEED -->
      <section class="section">
        <div class="section-header">
          <h2>Recent Jobs Feed</h2>
          <p>Last few jobs processed on the grid, including reward and preview.</p>
        </div>
        <div class="table-wrapper">
          <table class="jobs-table">
            <thead>
              <tr>
                <th>Job</th>
                <th>Model</th>
                <th>Reward</th>
                <th>Status</th>
                <th>Preview</th>
                <th>Completed</th>
              </tr>
            </thead>
            <tbody id="jobsFeedBody">
              <tr>
                <td colspan="6">Waiting for /jobs/recent...</td>
              </tr>
            </tbody>
          </table>
        </div>
      </section>

      <!-- NODE VISUALIZATION -->
      <section class="section">
        <div class="section-header">
          <h2>Node Grid</h2>
          <p>Live creator/worker nodes with GPU type, load, and heartbeat.</p>
        </div>
        <div class="node-grid" id="nodeGrid">
          <article class="node-card placeholder">
            <h3>Waiting for nodes...</h3>
            <p>Once <code>/nodes</code> responds, nodes will appear here.</p>
          </article>
        </div>
      </section>
    </main>

    <footer class="site-footer">
      <div class="footer-inner dashboard-footer">
        <div class="footer-patreon small">
          <span>Exclusive AI drops &amp; creator prompts</span>
          <a href="https://patreon.com/cw/u38989793" target="_blank" rel="noreferrer"
            >patreon.com/cw/u38989793</a
          >
        </div>
        <p class="footer-meta">HavnAI Grid · Development dashboard · Stage 6 → 7 Alpha</p>
      </div>
    </footer>

    <div id="jobDrawer" class="job-drawer hidden" aria-hidden="true">
      <button class="job-drawer-backdrop" aria-label="Close job details"></button>
      <aside class="job-drawer-panel" role="dialog" aria-modal="true">
        <div class="job-drawer-header">
          <div>
            <p class="job-drawer-kicker">Job Details</p>
            <h3>
              <span id="drawerJobIdShort">--</span>
              <button type="button" class="job-inline-button" id="drawerCopyId">Copy full ID</button>
            </h3>
            <div class="job-meta-row">
              <span class="status-pill" id="drawerStatusPill">Running</span>
              <span id="drawerCreatedAt"></span>
            </div>
          </div>
          <button type="button" class="job-drawer-close" id="drawerClose">Close</button>
        </div>
        <div class="job-drawer-body">
          <section class="job-section">
            <h4>Status Timeline</h4>
            <div class="status-timeline" id="drawerTimeline"></div>
          </section>
          <section class="job-section">
            <h4>Preview</h4>
            <div class="job-preview" id="drawerPreview"></div>
          </section>
          <section class="job-section">
            <h4>Actions</h4>
            <div class="job-actions">
              <button type="button" class="job-action-button" id="drawerDownload">Download output</button>
              <button type="button" class="job-action-button secondary" id="drawerCopyDebug">
                Copy debug info
              </button>
            </div>
            <p class="job-hint" id="drawerHint"></p>
          </section>
          <section class="job-section">
            <details open>
              <summary>Generation Params</summary>
              <div class="job-details-grid" id="drawerParams"></div>
            </details>
          </section>
          <section class="job-section">
            <details>
              <summary>Prompt</summary>
              <div class="job-details-stack">
                <div>
                  <span class="job-label">prompt</span>
                  <p id="drawerPrompt">--</p>
                </div>
                <div>
                  <span class="job-label">negative_prompt</span>
                  <p id="drawerNegativePrompt">--</p>
                </div>
              </div>
            </details>
          </section>
          <section class="job-section">
            <details>
              <summary>Routing / Node</summary>
              <div class="job-details-grid" id="drawerRouting"></div>
            </details>
          </section>
          <section class="job-section">
            <details>
              <summary>Raw Job JSON</summary>
              <pre class="job-raw" id="drawerRaw"></pre>
            </details>
          </section>
          <section class="job-section job-failure" id="drawerFailure" hidden>
            <h4>Failure Details</h4>
            <p id="drawerError">Unknown error</p>
            <ul>
              <li>Retry the job or pick a smaller frame count.</li>
              <li>Lower resolution or switch to a faster model.</li>
              <li>Copy debug info to share with support.</li>
            </ul>
          </section>
        </div>
      </aside>
    </div>

    <script>
      (function () {
        const API_BASE = window.NEXT_PUBLIC_API_BASE_URL || "/api";
        const ROOT_BASE = API_BASE.replace(/\\/api$/, "") || "";

        // Shared nav behavior
        const navToggle = document.getElementById("navToggle");
        const primaryNav = document.getElementById("primaryNav");
        navToggle.addEventListener("click", () => {
          primaryNav.classList.toggle("nav-open");
          navToggle.classList.toggle("nav-open");
        });

        // Elements
        const metricActiveNodes = document.getElementById("metricActiveNodes");
        const metricJobs24h = document.getElementById("metricJobs24h");
        const metricSuccessRate = document.getElementById("metricSuccessRate");
        const metricTopModel = document.getElementById("metricTopModel");
        const metricTotalNodes = document.getElementById("metricTotalNodes");
        const metricAvgUtil = document.getElementById("metricAvgUtil");
        const summaryUpdated = document.getElementById("summaryUpdated");

        const leaderboardBody = document.getElementById("leaderboardBody");
        const modelFilter = document.getElementById("modelFilter");

        const jobsFeedBody = document.getElementById("jobsFeedBody");
        const nodeGrid = document.getElementById("nodeGrid");

        const rangeButtons = Array.from(document.querySelectorAll(".range-btn"));
        const ctx = document.getElementById("jobsChart").getContext("2d");
        let jobsChart = null;
        let cachedJobs = [];
        let cachedModels = [];

        function safeArray(value) {
          return Array.isArray(value) ? value : [];
        }

        function setSummary(data, nodeSummary) {
          const nodes = data.active_nodes ?? nodeSummary?.online_nodes ?? "--";
          const jobs = data.jobs_completed_24h ?? "--";
          const success = data.success_rate ?? "--";
          const topModel = data.top_model ?? "--";

          metricActiveNodes.textContent = nodes;
          metricJobs24h.textContent = jobs;
          metricSuccessRate.textContent =
            typeof success === "number" ? success.toFixed(1) + "%" : success;
          metricTopModel.textContent = topModel;

          metricTotalNodes.textContent = nodeSummary?.total_nodes ?? "--";
          const avgUtil =
            typeof nodeSummary?.avg_utilization === "number"
              ? nodeSummary.avg_utilization.toFixed(1) + "%"
              : "--";
          metricAvgUtil.textContent = avgUtil;
          summaryUpdated.textContent = "Last Updated: " + new Date().toLocaleTimeString();
        }

        function renderLeaderboard(models) {
          const filter = modelFilter.value;
          const filtered = safeArray(models).filter((m) => {
            if (filter === "all") return true;
            const tags = safeArray(m.tags).map((t) => t.toString().toLowerCase());
            if (filter === "realism") return tags.includes("realism");
            if (filter === "anime") return tags.includes("anime");
            if (filter === "cartoon") return tags.includes("cartoon");
            return true;
          });

          if (!filtered.length) {
            leaderboardBody.innerHTML =
              '<tr><td colspan="4">No models match the current filter.</td></tr>';
            return;
          }

          const sorted = filtered
            .slice()
            .sort((a, b) => (b.weight || 0) - (a.weight || 0))
            .slice(0, 32);

          const rows = sorted
            .map((entry, index) => {
              const name = entry.name || entry.model || "unnamed-model";
              const weight = entry.weight ?? entry.reward_weight ?? 0;
              const tags = safeArray(entry.tags);
              let rankClass = "";
              if (index === 0) rankClass = "gold";
              else if (index === 1) rankClass = "silver";
              else if (index === 2) rankClass = "bronze";
              return `
                <tr class="${rankClass}">
                  <td>${index + 1}</td>
                  <td>${name}</td>
                  <td>${weight}</td>
                  <td>${tags.join(", ")}</td>
                </tr>
              `;
            })
            .join("");

          leaderboardBody.innerHTML = rows;
        }

        function buildJobSeries(jobs, rangeHours) {
          const now = Date.now();
          const cutoff = now - rangeHours * 60 * 60 * 1000;
          const buckets = new Map();

          safeArray(jobs).forEach((job) => {
            const tsRaw = job.completed_at || job.timestamp || job.submitted_at;
            if (!tsRaw) return;
            const ts =
              typeof tsRaw === "number" ? tsRaw * 1000 : Date.parse(tsRaw.toString());
            if (Number.isNaN(ts) || ts < cutoff) return;
            const minute = Math.floor(ts / 60000) * 60000;
            buckets.set(minute, (buckets.get(minute) || 0) + 1);
          });

          if (!buckets.size) {
            // Fallback synthetic trend
            const labels = [];
            const data = [];
            const points = 12;
            for (let i = points - 1; i >= 0; i--) {
              const t = now - (i * rangeHours * 60 * 60 * 1000) / points;
              labels.push(new Date(t).toLocaleTimeString());
              data.push(Math.round(Math.random() * 4));
            }
            return { labels, data };
          }

          const sortedKeys = Array.from(buckets.keys()).sort((a, b) => a - b);
          const labels = sortedKeys.map((ms) => new Date(ms).toLocaleTimeString());
          const data = sortedKeys.map((ms) => buckets.get(ms));
          return { labels, data };
        }

        function renderJobsChart(jobs, range) {
          const rangeHours = range === "1h" ? 1 : range === "6h" ? 6 : 24;
          const { labels, data } = buildJobSeries(jobs, rangeHours);

          const config = {
            type: "line",
            data: {
              labels,
              datasets: [
                {
                  label: "Jobs",
                  data,
                  borderColor: "#00eaff",
                  backgroundColor: "rgba(0, 234, 255, 0.25)",
                  tension: 0.25,
                  pointRadius: 2,
                  pointHoverRadius: 4,
                },
              ],
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: {
                  display: false,
                },
              },
              scales: {
                x: {
                  ticks: { color: "#9db3c4", maxRotation: 0, autoSkip: true },
                  grid: { color: "rgba(255,255,255,0.04)" },
                },
                y: {
                  beginAtZero: true,
                  ticks: { color: "#9db3c4", precision: 0 },
                  grid: { color: "rgba(255,255,255,0.04)" },
                },
              },
            },
          };

          if (jobsChart) {
            jobsChart.destroy();
          }
          jobsChart = new Chart(ctx, config);
        }

        function shortJobId(id) {
          if (!id) return "--";
          return id.length <= 12 ? id : `${id.slice(0, 6)}...${id.slice(-4)}`;
        }

        function normalizeStatus(rawStatus) {
          const status = String(rawStatus || "").toLowerCase();
          if (["failed", "error", "cancelled", "canceled"].includes(status)) {
            return { pill: "Failed", activeIndex: 4, isFailed: true, label: "Failed" };
          }
          if (["success", "completed", "ready"].includes(status)) {
            return { pill: "Ready", activeIndex: 4, isFailed: false, label: "Ready" };
          }
          if (["queued", "pending"].includes(status)) {
            return { pill: "Running", activeIndex: 0, isFailed: false, label: "Queued" };
          }
          if (["assigned"].includes(status)) {
            return { pill: "Running", activeIndex: 1, isFailed: false, label: "Assigned" };
          }
          if (["uploading"].includes(status)) {
            return { pill: "Running", activeIndex: 3, isFailed: false, label: "Uploading" };
          }
          if (["running", "processing", "in_progress"].includes(status)) {
            return { pill: "Running", activeIndex: 2, isFailed: false, label: "Running" };
          }
          return { pill: "Running", activeIndex: 2, isFailed: false, label: "Running (unknown)" };
        }

        function resolveAssetUrl(path) {
          if (!path) return "";
          if (/^https?:\/\//i.test(path)) return path;
          return API_BASE + path;
        }

        function parseJobData(raw) {
          if (!raw) return {};
          if (typeof raw === "string") {
            try {
              const parsed = JSON.parse(raw);
              return parsed && typeof parsed === "object" ? parsed : {};
            } catch {
              return {};
            }
          }
          return typeof raw === "object" ? raw : {};
        }

        function truncateText(value, limit) {
          if (!value) return value;
          if (value.length <= limit) return value;
          return value.slice(0, limit) + "...";
        }

        function formatIso(value) {
          if (!value) return "";
          const date = new Date(value);
          return Number.isNaN(date.getTime()) ? "" : date.toLocaleString();
        }

        function renderDrawerTimeline(container, normalized) {
          const steps = normalized.isFailed
            ? ["Queued", "Assigned", "Running", "Uploading", "Failed"]
            : ["Queued", "Assigned", "Running", "Uploading", "Ready"];
          container.innerHTML = steps
            .map((label, index) => {
              const isActive = index === normalized.activeIndex;
              const isComplete = index < normalized.activeIndex;
              const isFailed = normalized.isFailed && label === "Failed";
              return `
                <div class="timeline-step${isActive ? " is-active" : ""}${isComplete ? " is-complete" : ""}${isFailed ? " is-failed" : ""}">
                  <span class="timeline-dot"></span>
                  <span>${label}</span>
                </div>
              `;
            })
            .join("");
        }

        const jobDrawer = document.getElementById("jobDrawer");
        const drawerBackdrop = jobDrawer.querySelector(".job-drawer-backdrop");
        const drawerClose = document.getElementById("drawerClose");
        const drawerJobIdShort = document.getElementById("drawerJobIdShort");
        const drawerCopyId = document.getElementById("drawerCopyId");
        const drawerStatusPill = document.getElementById("drawerStatusPill");
        const drawerCreatedAt = document.getElementById("drawerCreatedAt");
        const drawerTimeline = document.getElementById("drawerTimeline");
        const drawerPreview = document.getElementById("drawerPreview");
        const drawerDownload = document.getElementById("drawerDownload");
        const drawerCopyDebug = document.getElementById("drawerCopyDebug");
        const drawerHint = document.getElementById("drawerHint");
        const drawerParams = document.getElementById("drawerParams");
        const drawerPrompt = document.getElementById("drawerPrompt");
        const drawerNegativePrompt = document.getElementById("drawerNegativePrompt");
        const drawerRouting = document.getElementById("drawerRouting");
        const drawerRaw = document.getElementById("drawerRaw");
        const drawerFailure = document.getElementById("drawerFailure");
        const drawerError = document.getElementById("drawerError");

        const drawerState = {
          jobId: null,
          debugPayload: null,
          downloadUrl: "",
        };

        function setDrawerOpen(open) {
          if (!jobDrawer) return;
          jobDrawer.classList.toggle("hidden", !open);
          jobDrawer.setAttribute("aria-hidden", open ? "false" : "true");
        }

        function setStatusPill(pill) {
          drawerStatusPill.textContent = pill;
          drawerStatusPill.className = "status-pill status-" + pill.toLowerCase();
        }

        async function openJobDrawer(summary) {
          if (!summary || !summary.job_id) return;
          drawerState.jobId = summary.job_id;
          drawerHint.textContent = "Loading job details...";
          setDrawerOpen(true);

          const normalized = normalizeStatus(summary.status);
          setStatusPill(normalized.pill);
          renderDrawerTimeline(drawerTimeline, normalized);
          drawerJobIdShort.textContent = shortJobId(summary.job_id);
          drawerCreatedAt.textContent = summary.submitted_at
            ? "Created " + formatIso(summary.submitted_at)
            : "";

          const previewUrl = resolveAssetUrl(summary.video_url || summary.image_url);
          drawerPreview.innerHTML = previewUrl
            ? summary.video_url
              ? `<video src="${previewUrl}" controls playsinline></video>`
              : `<img src="${previewUrl}" alt="${summary.job_id} preview" />`
            : `<div class="job-preview-empty">Preview not available</div>`;

          try {
            const jobRes = await fetch(`${API_BASE}/jobs/${encodeURIComponent(summary.job_id)}`);
            const job = jobRes.ok ? await jobRes.json() : null;
            let result = null;
            try {
              const resultRes = await fetch(`${API_BASE}/result/${encodeURIComponent(summary.job_id)}`);
              if (resultRes.ok) {
                result = await resultRes.json();
              }
            } catch {
              result = null;
            }

            const jobData = parseJobData(job && job.data);
            const promptText = truncateText(jobData.prompt, 500) || "--";
            const negativeText = truncateText(jobData.negative_prompt, 500) || "--";

            const params = {
              seed: jobData.seed ?? jobData.overrides?.seed,
              steps: jobData.steps ?? jobData.num_steps ?? jobData.overrides?.steps,
              guidance: jobData.guidance ?? jobData.overrides?.guidance,
              width: jobData.width ?? jobData.overrides?.width,
              height: jobData.height ?? jobData.overrides?.height,
              fps: jobData.fps,
              frames: jobData.frames,
              sampler: jobData.sampler ?? jobData.overrides?.sampler,
            };

            drawerParams.innerHTML = Object.entries(params)
              .filter(([, value]) => value != null)
              .map(
                ([key, value]) => `
                  <div>
                    <span class="job-label">${key}</span>
                    <span>${value}</span>
                  </div>
                `
              )
              .join("");

            drawerPrompt.textContent = promptText;
            drawerNegativePrompt.textContent = negativeText;
            drawerRouting.innerHTML = `
              <div>
                <span class="job-label">node_id</span>
                <span>${job?.node_id || "--"}</span>
              </div>
              <div>
                <span class="job-label">engine</span>
                <span>${job?.task_type || summary.task_type || "--"}</span>
              </div>
              <div>
                <span class="job-label">model</span>
                <span>${job?.model || summary.model || "--"}</span>
              </div>
            `;
            drawerRaw.textContent = JSON.stringify(job?.data || summary, null, 2);

            const outputImage = resolveAssetUrl(result?.image_url || summary.image_url);
            const outputVideo = resolveAssetUrl(result?.video_url || summary.video_url);
            drawerState.downloadUrl = outputVideo || outputImage || "";

            const debugPayload = {
              job_id: summary.job_id,
              status: job?.status || summary.status,
              timestamps: {
                created_at: summary.submitted_at || "",
                completed_at: summary.completed_at || "",
              },
              model: job?.model || summary.model,
              engine: jobData.engine || job?.task_type || summary.task_type,
              node_id: job?.node_id || jobData.node_id || jobData.worker_id,
              worker_id: jobData.worker_id || job?.node_id,
              params,
              prompt: promptText,
              negative_prompt: negativeText,
              output_urls: {
                image_url: outputImage,
                video_url: outputVideo,
              },
              preview_url: outputImage || outputVideo,
              error_message: jobData.error_message || jobData.error || jobData.failure_reason || undefined,
            };

            drawerState.debugPayload = debugPayload;
            const isFailed = normalizeStatus(job?.status || summary.status).isFailed;
            drawerFailure.hidden = !isFailed;
            drawerError.textContent = debugPayload.error_message || "Unknown error";
            drawerHint.textContent = "";
          } catch (err) {
            drawerHint.textContent = "Failed to load job details.";
          }
        }

        drawerBackdrop.addEventListener("click", () => setDrawerOpen(false));
        drawerClose.addEventListener("click", () => setDrawerOpen(false));
        drawerCopyId.addEventListener("click", async () => {
          if (!drawerState.jobId || !navigator.clipboard) return;
          try {
            await navigator.clipboard.writeText(drawerState.jobId);
          } catch {}
        });
        drawerCopyDebug.addEventListener("click", async () => {
          if (!drawerState.debugPayload || !navigator.clipboard) return;
          try {
            await navigator.clipboard.writeText(JSON.stringify(drawerState.debugPayload, null, 2));
          } catch {}
        });
        drawerDownload.addEventListener("click", async () => {
          if (!drawerState.downloadUrl) return;
          try {
            const res = await fetch(drawerState.downloadUrl);
            if (!res.ok) throw new Error("download failed");
            const blob = await res.blob();
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = drawerState.downloadUrl.split("/").pop() || "havnai-output";
            document.body.appendChild(link);
            link.click();
            link.remove();
            setTimeout(() => URL.revokeObjectURL(url), 1000);
          } catch {}
        });

        function renderJobsFeed(jobs) {
          const list = safeArray(jobs);
          if (!list.length) {
            jobsFeedBody.innerHTML =
              '<tr><td colspan="6">No recent jobs yet. Submit via /submit-job to see activity.</td></tr>';
            return;
          }

          const rows = list
            .slice(0, 20)
            .map((job) => {
              const id = job.job_id || job.id || "—";
              const model = job.model || "—";
              const reward =
                typeof job.reward_hai === "number"
                  ? job.reward_hai.toFixed(6)
                  : typeof job.reward === "number"
                  ? job.reward.toFixed(6)
                  : "—";
              const status = (job.status || "UNKNOWN").toString().toUpperCase();
              const completedRaw = job.completed_at || job.timestamp || null;
              const completed = completedRaw
                ? new Date(
                    typeof completedRaw === "number" ? completedRaw * 1000 : completedRaw
                  ).toLocaleTimeString()
                : "—";
              const imageUrl = job.image_url || job.preview_url || "";
              const videoUrl = job.video_url || "";
              const preview = imageUrl
                ? `<div class="jobs-preview-tile"><img src="${imageUrl}" alt="${id} preview" loading="lazy" /></div>`
                : `<div class="jobs-preview-tile">No preview</div>`;

              return `
                <tr class="jobs-row-clickable" data-job-id="${id}" data-job-model="${model}" data-job-status="${status}" data-job-task="${job.task_type || ""}" data-job-submitted="${job.submitted_at || ""}" data-job-completed="${job.completed_at || ""}" data-job-image="${imageUrl}" data-job-video="${videoUrl}">
                  <td><code>${id}</code></td>
                  <td>${model}</td>
                  <td>${reward}</td>
                  <td>${status}</td>
                  <td>${preview}</td>
                  <td>${completed}</td>
                </tr>
              `;
            })
            .join("");

          jobsFeedBody.innerHTML = rows;
        }

        function renderNodes(nodes) {
          const list = safeArray(nodes);
          if (!list.length) {
            nodeGrid.innerHTML =
              '<article class="node-card placeholder"><h3>No nodes yet</h3><p>Once nodes register with the coordinator, they will appear here.</p></article>';
            return;
          }

          const cards = list
            .slice()
            .sort((a, b) => {
              const utilA = a.avg_utilization ?? a.gpu_utilization ?? 0;
              const utilB = b.avg_utilization ?? b.gpu_utilization ?? 0;
              return utilB - utilA;
            })
            .map((node) => {
              const name = node.node_name || node.node_id;
              const status = node.status || "offline";
              const util = (node.avg_utilization ?? node.gpu_utilization ?? 0).toFixed(1);
              const uptime = node.uptime_human || "—";
              const lastSeen = node.last_seen || "—";
              const role = node.role || "worker";
              const gpuName =
                (node.gpu && (node.gpu.model || node.gpu.gpu_name)) ||
                (node.last_result &&
                  node.last_result.metrics &&
                  node.last_result.metrics.gpu_name) ||
                "Unknown GPU";
              return `
                <article class="node-card ${status === "online" ? "online" : "offline"}">
                  <header>
                    <h3>${name}</h3>
                    <span class="node-role">${role}</span>
                  </header>
                  <dl>
                    <div>
                      <dt>GPU</dt>
                      <dd>${gpuName}</dd>
                    </div>
                    <div>
                      <dt>Uptime</dt>
                      <dd>${uptime}</dd>
                    </div>
                    <div>
                      <dt>Load</dt>
                      <dd>${util}%</dd>
                    </div>
                    <div>
                      <dt>Last heartbeat</dt>
                      <dd>${lastSeen}</dd>
                    </div>
                  </dl>
                  <footer>
                    <span class="node-status">${status}</span>
                  </footer>
                </article>
              `;
            })
            .join("");

          nodeGrid.innerHTML = cards;
        }

        async function fetchStatsAndModels() {
          try {
            const res = await fetch(API_BASE + "/models/stats", { credentials: "same-origin" });
            if (!res.ok) throw new Error("stats HTTP " + res.status);
            const data = await res.json();
            cachedModels = safeArray(data.model_registry || data.models || []);
            setSummary(data, null);
            renderLeaderboard(cachedModels);
          } catch (err) {
            console.error("Failed to fetch /api/models/stats", err);
          }
        }

        async function fetchJobs() {
          try {
            const res = await fetch(API_BASE + "/jobs/recent?limit=25", {
              credentials: "same-origin",
            });
            if (!res.ok) throw new Error("jobs HTTP " + res.status);
            const data = await res.json();
            cachedJobs = safeArray(data.jobs || data.feed || []);
            renderJobsFeed(cachedJobs);
            renderJobsChart(cachedJobs, "1h");
          } catch (err) {
            console.error("Failed to fetch /jobs/recent", err);
          }
        }

        async function fetchNodes() {
          try {
            const res = await fetch(ROOT_BASE + "/nodes", { credentials: "same-origin" });
            if (!res.ok) throw new Error("nodes HTTP " + res.status);
            const data = await res.json();
            renderNodes(data.nodes || []);
            setSummary(
              {
                active_nodes: data.summary?.online_nodes,
                jobs_completed_24h: undefined,
                success_rate: undefined,
                top_model: undefined,
              },
              data.summary || null
            );
          } catch (err) {
            console.error("Failed to fetch /nodes", err);
          }
        }

        // Range toggles
        rangeButtons.forEach((btn) => {
          btn.addEventListener("click", () => {
            rangeButtons.forEach((b) => b.classList.remove("active"));
            btn.classList.add("active");
            const range = btn.getAttribute("data-range") || "1h";
            renderJobsChart(cachedJobs, range);
          });
        });

        modelFilter.addEventListener("change", () => {
          renderLeaderboard(cachedModels);
        });

        // Lightbox for previews
        const body = document.body;
        function ensureLightbox() {
          let lb = document.getElementById("lightbox");
          if (!lb) {
            lb = document.createElement("div");
            lb.id = "lightbox";
            lb.className = "lightbox hidden";
            lb.innerHTML =
              '<div class="lightbox-backdrop"></div><div class="lightbox-content"><img alt="Preview" /><button class="lightbox-close" aria-label="Close preview">×</button></div>';
            body.appendChild(lb);
            lb.addEventListener("click", (evt) => {
              if (
                evt.target === lb ||
                evt.target.classList.contains("lightbox-backdrop") ||
                evt.target.classList.contains("lightbox-close")
              ) {
                lb.classList.add("hidden");
              }
            });
          }
          return lb;
        }

        jobsFeedBody.addEventListener("click", (evt) => {
          const row = evt.target.closest("tr[data-job-id]");
          if (!row) return;
          const summary = {
            job_id: row.getAttribute("data-job-id"),
            model: row.getAttribute("data-job-model") || "—",
            status: row.getAttribute("data-job-status") || "UNKNOWN",
            task_type: row.getAttribute("data-job-task") || "",
            submitted_at: row.getAttribute("data-job-submitted") || "",
            completed_at: row.getAttribute("data-job-completed") || "",
            image_url: row.getAttribute("data-job-image") || "",
            video_url: row.getAttribute("data-job-video") || "",
          };
          openJobDrawer(summary);
        });

        // Initial load + polling
        fetchStatsAndModels();
        fetchJobs();
        fetchNodes();
        setInterval(fetchStatsAndModels, 15000);
        setInterval(fetchJobs, 15000);
        setInterval(fetchNodes, 20000);
      })();
    </script>
  </body>
</html>
